// ==============================================================================
// meas_topcharge_su2.cc
// ==============================================================================
// Topological charge measurement program for SU(2) lattice gauge configurations.
// Reads gauge field configurations generated by the heatbath algorithm and
// measures the topological charge after applying APE smearing.
//
// Usage:
//   meas_topcharge -i <input_file>
//
// Input file format:
//   config_dir  <directory containing gauge configurations>
//   output_dir  <directory for output files>
//   beta        <coupling constant>
//   T           <temporal extent>
//   L           <spatial extent>
//   start_conf  <first configuration number>
//   end_conf    <last configuration number>
//   conf_step   <step between configurations>
//   smear_steps <number of smearing steps>
//   smear_alpha <APE smearing parameter>
//
// Output:
//   Topological charge Q as a function of Monte Carlo time and smearing steps.
//
// Author: Alexander de Barros Noll
// Original implementation: Carolin Riehl (2020)
// Date: January 2026
// ==============================================================================

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <string>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <vector>
#include <sys/stat.h>

// SU(2) utility library headers
#include "fields.hh"
#include "geometry.hh"
#include "io.hh"
#include "linear_algebra.hh"
#include "smearing_techniques.hh"
#include "ranlux.hh"

// Local headers
#include "topcharge_su2.hh"
#include "Plaquette.hh"
#include "progressbar.hh"

// ==============================================================================
// Global Variables
// ==============================================================================

// Lattice dimensions
int T = 16;  // Temporal extent
int L = 16;  // Spatial extent

// Boundary conditions
bool open_boundary_conditions = false;

// ==============================================================================
// Simulation Parameters
// ==============================================================================

struct SimulationParams {
    std::string config_dir;        // Directory containing configurations
    std::string output_dir;        // Output directory
    double beta;                   // Coupling constant
    int T;                         // Temporal extent
    int L;                         // Spatial extent
    int start_conf;                // First configuration
    int end_conf;                  // Last configuration
    int conf_step;                 // Step between configurations
    int smear_steps;               // Total number of smearing steps
    int smear_interval;            // Output interval for smearing steps
    double smear_alpha;            // APE smearing parameter
    int seed;                      // Random seed
    
    // MC parameters (read but not used here, for unified file)
    int num_sweeps;
    int save_interval;
};

// ==============================================================================
// Input File Parser
// ==============================================================================

/**
 * @brief Reads simulation parameters from input file.
 * 
 * @param filename Input file path
 * @param params Output: simulation parameters
 * @return true if successful, false otherwise
 */
bool read_input_file(const char *filename, SimulationParams &params) {
    std::ifstream infile(filename);
    if (!infile.is_open()) {
        std::cerr << "Error: Cannot open input file: " << filename << std::endl;
        return false;
    }
    
    std::string line, key;
    
    // Set defaults
    params.config_dir = "output/configs/";
    params.output_dir = "output/";
    params.beta = 2.5;
    params.T = 8;
    params.L = 8;
    params.start_conf = 10;
    params.end_conf = 100;
    params.conf_step = 10;
    params.smear_steps = 40;
    params.smear_interval = 10;
    params.smear_alpha = 0.5;
    params.seed = 12345;
    params.num_sweeps = 100;
    params.save_interval = 10;
    
    while (std::getline(infile, line)) {
        // Skip comments and empty lines
        if (line.empty() || line[0] == '#') continue;
        
        std::istringstream iss(line);
        iss >> key;
        
        if (key == "config_dir") {
            iss >> params.config_dir;
        } else if (key == "output_dir") {
            iss >> params.output_dir;
        } else if (key == "beta") {
            iss >> params.beta;
        } else if (key == "T") {
            iss >> params.T;
        } else if (key == "L") {
            iss >> params.L;
        } else if (key == "start_conf") {
            iss >> params.start_conf;
        } else if (key == "end_conf") {
            iss >> params.end_conf;
        } else if (key == "conf_step") {
            iss >> params.conf_step;
        } else if (key == "smear_steps") {
            iss >> params.smear_steps;
        } else if (key == "smear_interval") {
            iss >> params.smear_interval;
        } else if (key == "smear_alpha") {
            iss >> params.smear_alpha;
        } else if (key == "seed") {
            iss >> params.seed;
        } else if (key == "num_sweeps") {
            iss >> params.num_sweeps;
        } else if (key == "save_interval") {
            iss >> params.save_interval;
        }
    }
    
    // If end_conf not explicitly set, derive from num_sweeps
    // This allows using unified file without specifying end_conf
    if (params.end_conf < params.start_conf) {
        params.end_conf = params.num_sweeps;
    }
    
    infile.close();
    return true;
}

/**
 * @brief Validates simulation parameters.
 */
bool validate_params(const SimulationParams &params) {
    if (params.config_dir.empty()) {
        std::cerr << "Error: config_dir not specified" << std::endl;
        return false;
    }
    if (params.output_dir.empty()) {
        std::cerr << "Error: output_dir not specified" << std::endl;
        return false;
    }
    if (params.T < 2 || params.L < 2) {
        std::cerr << "Error: Invalid lattice size (T=" << params.T << ", L=" << params.L << ")" << std::endl;
        return false;
    }
    if (params.start_conf > params.end_conf) {
        std::cerr << "Error: start_conf > end_conf" << std::endl;
        return false;
    }
    if (params.smear_alpha < 0.0 || params.smear_alpha > 1.0) {
        std::cerr << "Warning: smear_alpha=" << params.smear_alpha << " outside typical range [0, 1]" << std::endl;
    }
    return true;
}

/**
 * @brief Prints simulation parameters.
 */
void print_params(const SimulationParams &params) {
    std::cout << "========================================" << std::endl;
    std::cout << "SU(2) Topological Charge Measurement" << std::endl;
    std::cout << "========================================" << std::endl;
    std::cout << "Configuration directory: " << params.config_dir << std::endl;
    std::cout << "Output directory:        " << params.output_dir << std::endl;
    std::cout << "Beta:                    " << params.beta << std::endl;
    std::cout << "Lattice size:            " << params.T << " x " << params.L << "^3" << std::endl;
    std::cout << "Configurations:          " << params.start_conf << " to " << params.end_conf;
    std::cout << " (step " << params.conf_step << ")" << std::endl;
    std::cout << "Smearing steps:          " << params.smear_steps << std::endl;
    std::cout << "Smearing output interval:" << params.smear_interval << std::endl;
    std::cout << "Smearing alpha:          " << params.smear_alpha << std::endl;
    std::cout << "========================================" << std::endl;
}

// ==============================================================================
// Main Program
// ==============================================================================

int main(int argc, char *argv[]) {
    // Parse command line arguments
    const char *input_file = nullptr;
    
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-i") == 0 && i + 1 < argc) {
            input_file = argv[i + 1];
            i++;
        }
    }
    
    if (input_file == nullptr) {
        std::cerr << "Usage: " << argv[0] << " -i <input_file>" << std::endl;
        std::cerr << std::endl;
        std::cerr << "Input file format:" << std::endl;
        std::cerr << "  config_dir        <path>    # Directory with gauge configurations" << std::endl;
        std::cerr << "  output_dir        <path>    # Output directory" << std::endl;
        std::cerr << "  beta              <value>   # Coupling constant" << std::endl;
        std::cerr << "  T                 <value>   # Temporal lattice extent" << std::endl;
        std::cerr << "  L                 <value>   # Spatial lattice extent" << std::endl;
        std::cerr << "  start_conf        <value>   # First configuration number" << std::endl;
        std::cerr << "  end_conf          <value>   # Last configuration number" << std::endl;
        std::cerr << "  conf_step         <value>   # Step between configurations" << std::endl;
        std::cerr << "  smear_steps       <value>   # Number of smearing steps" << std::endl;
        std::cerr << "  smear_alpha       <value>   # APE smearing parameter" << std::endl;
        return EXIT_FAILURE;
    }
    
    // Read and validate parameters
    SimulationParams params;
    if (!read_input_file(input_file, params)) {
        return EXIT_FAILURE;
    }
    if (!validate_params(params)) {
        return EXIT_FAILURE;
    }
    
    print_params(params);
    
    // Set global lattice dimensions
    T = params.T;
    L = params.L;
    
    // Initialize random number generator
    InitializeRand(params.seed);
    
    // Create output directory if it doesn't exist
    mkdir(params.output_dir.c_str(), 0755);
    
    // Open output file - generic name
    std::string output_filename = params.output_dir + "topcharge.dat";
    
    std::ofstream outfile(output_filename);
    if (!outfile.is_open()) {
        std::cerr << "Error: Cannot open output file: " << output_filename << std::endl;
        return EXIT_FAILURE;
    }
    
    // Write minimal header
    outfile << "# smear_steps  config_number  Q  plaquette" << std::endl;
    
    // Allocate gauge field
    double *gauge_field = nullptr;
    double *smeared_gauge_field = nullptr;
    
    Gauge_Field_Alloc(&gauge_field, T, L);
    Gauge_Field_Alloc(&smeared_gauge_field, T, L);
    
    // Loop over configurations
    int n_configs = 0;
    
    // Calculate total number of configurations
    int total_configs = (params.end_conf - params.start_conf) / params.conf_step + 1;
    
    for (int n = params.start_conf; n <= params.end_conf; n += params.conf_step) {
        // Construct configuration filename
        char config_filename[1024];
        snprintf(config_filename, sizeof(config_filename), 
                 "%sconf.%04d", params.config_dir.c_str(), n);
        
        // Update progress bar
        double progress = static_cast<double>(n_configs) / total_configs;
        progress_bar(progress);
        
        // Read configuration
        read_gauge_field(gauge_field, config_filename, T, L);
        
        // Loop over smearing steps
        for (int smear = 0; smear <= params.smear_steps; smear += params.smear_interval) {
            // Copy gauge field for smearing
            if (smear == 0) {
                Gauge_Field_Copy(smeared_gauge_field, gauge_field, T, L);
            } else {
                // Apply smearing steps
                for (int s = 0; s < params.smear_interval; s++) {
                    APE_Smearing_all(smeared_gauge_field, T, L, params.smear_alpha);
                }
            }
            
            // Compute topological charge
            double Q = compute_topological_charge(smeared_gauge_field, T, L);
            
            // Compute average plaquette
            double plaq = Average_Plaquette(smeared_gauge_field, T, L);
            
            // Output results
            outfile << std::fixed << std::setprecision(6);
            outfile << std::setw(5) << smear << "  ";
            outfile << std::setw(6) << n << "  ";
            outfile << std::setw(12) << Q << "  ";
            outfile << std::setw(10) << plaq << std::endl;
        }
        
        n_configs++;
    }
    
    // Clear progress bar
    progress_bar_clear();
    
    // Cleanup
    outfile.close();
    Gauge_Field_Free(&gauge_field);
    Gauge_Field_Free(&smeared_gauge_field);
    
    std::cout << "========================================" << std::endl;
    std::cout << "Measurement complete." << std::endl;
    std::cout << "Processed " << n_configs << " configurations." << std::endl;
    std::cout << "Output written to: " << output_filename << std::endl;
    std::cout << "========================================" << std::endl;
    
    return EXIT_SUCCESS;
}
